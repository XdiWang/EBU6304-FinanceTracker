package com.financetracker.model;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import static org.junit.jupiter.api.Assertions.*;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.time.LocalDate;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

class AccountTest {

    private Account account;
    private Category testCategory;

    @BeforeEach
    void setUp() {
        account = new Account("Test Bank Account", Account.AccountType.BANK);
        testCategory = new Category("Test Category");
    }

    @Test
    @DisplayName("Constructor should initialize account correctly")
    void constructor_initializesCorrectly() {
        assertEquals("Test Bank Account", account.getName());
        assertEquals(Account.AccountType.BANK, account.getType());
        assertEquals(0.0, account.getBalance(), 0.001);
        assertTrue(account.getTransactions().isEmpty());
    }

    @Test
    @DisplayName("addTransaction should update balance and add to list for income")
    void addTransaction_income_updatesBalanceAndList() {
        Transaction income = new Transaction("T1", LocalDate.now(), 100.0, "Salary", testCategory, Transaction.TransactionType.INCOME, null);
        account.addTransaction(income);

        assertEquals(100.0, account.getBalance(), 0.001);
        assertEquals(1, account.getTransactions().size());
        assertTrue(account.getTransactions().contains(income));
        assertEquals(account, income.getAccount(), "Transaction should be associated with this account.");
    }

    @Test
    @DisplayName("addTransaction should update balance and add to list for expense")
    void addTransaction_expense_updatesBalanceAndList() {
        Transaction expense = new Transaction("T2", LocalDate.now(), -50.0, "Groceries", testCategory, Transaction.TransactionType.EXPENSE, null);
        account.addTransaction(expense);

        assertEquals(-50.0, account.getBalance(), 0.001);
        assertEquals(1, account.getTransactions().size());
        assertTrue(account.getTransactions().contains(expense));
    }

    @Test
    @DisplayName("addTransaction with null transaction should not change account")
    void addTransaction_nullTransaction_noChange() {
        account.addTransaction(null);
        assertEquals(0.0, account.getBalance(), 0.001);
        assertTrue(account.getTransactions().isEmpty());
    }

    @Test
    @DisplayName("addTransaction should not add transaction already belonging to another account")
    void addTransaction_transactionBelongingToAnotherAccount_isIgnored() {
        Account otherAccount = new Account("Other Account", Account.AccountType.CASH);
        Transaction transaction = new Transaction("T3", LocalDate.now(), 20.0, "Gift", testCategory, Transaction.TransactionType.INCOME, otherAccount);

        // This should print an error message to System.err as per Account.java logic
        // and not add the transaction.
        account.addTransaction(transaction);

        assertEquals(0.0, account.getBalance(), 0.001);
        assertTrue(account.getTransactions().isEmpty());
    }

    @Test
    @DisplayName("addTransaction should not add the same transaction instance twice")
    void addTransaction_sameInstanceTwice_addedOnlyOnce() {
        Transaction income = new Transaction("T1", LocalDate.now(), 100.0, "Salary", testCategory, Transaction.TransactionType.INCOME, null);
        account.addTransaction(income);
        account.addTransaction(income); // Try adding again

        assertEquals(100.0, account.getBalance(), 0.001);
        assertEquals(1, account.getTransactions().size());
    }


    @Test
    @DisplayName("removeTransaction should update balance and remove from list")
    void removeTransaction_updatesBalanceAndList() {
        Transaction income = new Transaction("T1", LocalDate.now(), 100.0, "Salary", testCategory, Transaction.TransactionType.INCOME, null);
        Transaction expense = new Transaction("T2", LocalDate.now(), -30.0, "Coffee", testCategory, Transaction.TransactionType.EXPENSE, null);
        account.addTransaction(income);
        account.addTransaction(expense); // Balance = 70.0

        account.removeTransaction(expense);

        assertEquals(100.0, account.getBalance(), 0.001, "Balance should revert after removing expense.");
        assertEquals(1, account.getTransactions().size());
        assertFalse(account.getTransactions().contains(expense));
        assertTrue(account.getTransactions().contains(income));
    }

    @Test
    @DisplayName("removeTransaction non-existent transaction should not change account")
    void removeTransaction_nonExistent_noChange() {
        Transaction income = new Transaction("T1", LocalDate.now(), 100.0, "Salary", testCategory, Transaction.TransactionType.INCOME, null);
        Transaction nonExistent = new Transaction("T99", LocalDate.now(), -10.0, "Ghost", testCategory, Transaction.TransactionType.EXPENSE, null);
        account.addTransaction(income);

        account.removeTransaction(nonExistent);
        assertEquals(100.0, account.getBalance(), 0.001);
        assertEquals(1, account.getTransactions().size());
    }

    @Test
    @DisplayName("calculateBalance should correctly sum transaction amounts")
    void calculateBalance_correctlySumsAmounts() {
        // Manually add transactions to the internal list to bypass addTransaction's balance update
        // This is to test calculateBalance in isolation if it were public,
        // but since it's called by add/remove, this test is more about verifying the overall effect.
        account.getTransactions().add(new Transaction("T1", LocalDate.now(), 200.0, "Bonus", testCategory, Transaction.TransactionType.INCOME, account));
        account.getTransactions().add(new Transaction("T2", LocalDate.now(), -75.0, "Dinner", testCategory, Transaction.TransactionType.EXPENSE, account));
        account.getTransactions().add(new Transaction("T3", LocalDate.now(), 50.0, "Refund", testCategory, Transaction.TransactionType.INCOME, account));

        account.calculateBalance(); // Explicitly call if testing in isolation (though it's private now)
        // For current design, addTransaction already calls it.
        // So, let's re-do with proper addTransaction calls
        account.clearTransactions(); // Start fresh
        account.addTransaction(new Transaction("T1", LocalDate.now(), 200.0, "Bonus", testCategory, Transaction.TransactionType.INCOME, null));
        account.addTransaction(new Transaction("T2", LocalDate.now(), -75.0, "Dinner", testCategory, Transaction.TransactionType.EXPENSE, null));
        account.addTransaction(new Transaction("T3", LocalDate.now(), 50.0, "Refund", testCategory, Transaction.TransactionType.INCOME, null));

        assertEquals(200.0 - 75.0 + 50.0, account.getBalance(), 0.001);
    }

    @Test
    @DisplayName("clearTransactions should reset balance and empty transaction list")
    void clearTransactions_resetsBalanceAndList() {
        account.addTransaction(new Transaction("T1", LocalDate.now(), 100.0, "Salary", testCategory, Transaction.TransactionType.INCOME, null));
        account.clearTransactions();

        assertEquals(0.0, account.getBalance(), 0.001);
        assertTrue(account.getTransactions().isEmpty());
    }

    @Test
    @DisplayName("getTransactions should return a copy of the internal list")
    void getTransactions_returnsCopy() {
        Transaction income = new Transaction("T1", LocalDate.now(), 100.0, "Salary", testCategory, Transaction.TransactionType.INCOME, null);
        account.addTransaction(income);

        List<Transaction> retrievedTransactions = account.getTransactions();
        retrievedTransactions.clear(); // Modify the retrieved list

        assertEquals(1, account.getTransactions().size(), "Internal list should not be affected by modifying the copy.");
    }

    @Test
    @DisplayName("setName and setType should update properties")
    void setNameAndType_updatesProperties() {
        account.setName("New Account Name");
        account.setType(Account.AccountType.CASH);

        assertEquals("New Account Name", account.getName());
        assertEquals(Account.AccountType.CASH, account.getType());
    }

    @Test
    @DisplayName("getFormattedBalance should return correctly formatted string")
    void getFormattedBalance_returnsCorrectFormat() {
        account.addTransaction(new Transaction("T1", LocalDate.now(), 1234.56, "Payment", testCategory, Transaction.TransactionType.INCOME, null));
        assertEquals("￥1,234.56", account.getFormattedBalance());

        account.clearTransactions();
        account.addTransaction(new Transaction("T2", LocalDate.now(), -789.00, "Bill", testCategory, Transaction.TransactionType.EXPENSE, null));
        assertEquals("-￥789.00", account.getFormattedBalance()); // Note: DecimalFormat might put minus outside currency symbol

        account.clearTransactions();
        assertEquals("￥0.00", account.getFormattedBalance());
    }

    @Test
    @DisplayName("PropertyChange event for 'balance' should be fired")
    void propertyChange_balanceFired() {
        AtomicBoolean eventFired = new AtomicBoolean(false);
        AtomicReference<Double> oldBalanceVal = new AtomicReference<>();
        AtomicReference<Double> newBalanceVal = new AtomicReference<>();

        PropertyChangeListener listener = evt -> {
            if ("balance".equals(evt.getPropertyName())) {
                eventFired.set(true);
                oldBalanceVal.set((Double) evt.getOldValue());
                newBalanceVal.set((Double) evt.getNewValue());
            }
        };
        account.addPropertyChangeListener(listener);

        account.addTransaction(new Transaction("T1", LocalDate.now(), 50.0, "Test", testCategory, Transaction.TransactionType.INCOME, null));

        assertTrue(eventFired.get(), "'balance' PropertyChangeEvent should have been fired.");
        assertEquals(0.0, oldBalanceVal.get(), 0.001);
        assertEquals(50.0, newBalanceVal.get(), 0.001);

        account.removePropertyChangeListener(listener); // Clean up
    }

    @Test
    @DisplayName("toString should return name and type display name")
    void toString_returnsNameAndType() {
        String expected = "Test Bank Account (银行账户)";
        assertEquals(expected, account.toString());
    }
}
